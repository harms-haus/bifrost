#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# ── Module registry (derived from go.work) ──────────────────────────────────
MODULES=(core domain domain/integration providers/sqlite server cli)

BINARY_DIR=bin
SERVER_BINARY=bifrost-server
CLI_BINARY=bf

# ── Helpers ──────────────────────────────────────────────────────────────────

usage() {
  cat <<EOF
Usage: ./run <command> [module...] [-- extra-args...]

Commands:
  test   [module...]   Run tests (all modules if none specified)
  lint   [module...]   Run golangci-lint (all modules if none specified)
  vet    [module...]   Run go vet (all modules if none specified)
  build                Build server + CLI binaries
  build-server         Build the server binary
  build-cli            Build the CLI binary
  docker               Build Docker image
  clean                Remove build artifacts
  tidy   [module...]   Run go mod tidy (all modules if none specified)
  list                 List available modules

Modules: ${MODULES[*]}

Examples:
  ./run test                    # test everything
  ./run test core               # test only core
  ./run test core domain        # test core and domain
  ./run lint server cli         # lint server and cli
  ./run test core -- -v -count=1  # pass extra flags to go test
EOF
  exit "${1:-0}"
}

# Resolve module names to ./module/... paths
resolve_modules() {
  local targets=()
  for mod in "$@"; do
    # Strip trailing slashes and /...
    mod="${mod%/}"
    mod="${mod%/...}"
    # Validate
    local found=false
    for valid in "${MODULES[@]}"; do
      if [[ "$mod" == "$valid" ]]; then
        found=true
        break
      fi
    done
    if ! $found; then
      echo "error: unknown module '$mod'" >&2
      echo "valid modules: ${MODULES[*]}" >&2
      exit 1
    fi
    targets+=("./$mod/...")
  done
  echo "${targets[@]}"
}

# Parse args: split on "--" into modules and extra args
parse_args() {
  SELECTED_MODULES=()
  EXTRA_ARGS=()
  local past_separator=false
  for arg in "$@"; do
    if [[ "$arg" == "--" ]]; then
      past_separator=true
      continue
    fi
    if $past_separator; then
      EXTRA_ARGS+=("$arg")
    else
      SELECTED_MODULES+=("$arg")
    fi
  done
}

all_module_paths() {
  local paths=()
  for mod in "${MODULES[@]}"; do
    paths+=("./$mod/...")
  done
  echo "${paths[@]}"
}

# ── Commands ─────────────────────────────────────────────────────────────────

cmd_test() {
  parse_args "$@"
  local targets
  if [[ ${#SELECTED_MODULES[@]} -eq 0 ]]; then
    targets=$(all_module_paths)
  else
    targets=$(resolve_modules "${SELECTED_MODULES[@]}")
  fi
  echo "» go test ${EXTRA_ARGS[*]+"${EXTRA_ARGS[*]}"} $targets"
  # shellcheck disable=SC2086
  go test ${EXTRA_ARGS[@]+"${EXTRA_ARGS[@]}"} $targets
}

cmd_lint() {
  parse_args "$@"
  local targets
  if [[ ${#SELECTED_MODULES[@]} -eq 0 ]]; then
    targets=$(all_module_paths)
  else
    targets=$(resolve_modules "${SELECTED_MODULES[@]}")
  fi
  echo "» golangci-lint run ${EXTRA_ARGS[*]+"${EXTRA_ARGS[*]}"} $targets"
  # shellcheck disable=SC2086
  go tool golangci-lint run ${EXTRA_ARGS[@]+"${EXTRA_ARGS[@]}"} $targets
}

cmd_vet() {
  parse_args "$@"
  local targets
  if [[ ${#SELECTED_MODULES[@]} -eq 0 ]]; then
    targets=$(all_module_paths)
  else
    targets=$(resolve_modules "${SELECTED_MODULES[@]}")
  fi
  echo "» go vet ${EXTRA_ARGS[*]+"${EXTRA_ARGS[*]}"} $targets"
  # shellcheck disable=SC2086
  go vet ${EXTRA_ARGS[@]+"${EXTRA_ARGS[@]}"} $targets
}

cmd_tidy() {
  parse_args "$@"
  local mods=("${SELECTED_MODULES[@]}")
  if [[ ${#mods[@]} -eq 0 ]]; then
    mods=("${MODULES[@]}")
  fi
  for mod in "${mods[@]}"; do
    # Validate
    local found=false
    for valid in "${MODULES[@]}"; do
      if [[ "$mod" == "$valid" ]]; then
        found=true
        break
      fi
    done
    if ! $found; then
      echo "error: unknown module '$mod'" >&2
      exit 1
    fi
    echo "» go mod tidy  ($mod)"
    (cd "$mod" && go mod tidy)
  done
}

cmd_build() {
  cmd_build_server
  cmd_build_cli
}

cmd_build_server() {
  echo "» building server → $BINARY_DIR/$SERVER_BINARY"
  go build -o "$BINARY_DIR/$SERVER_BINARY" ./server/cmd
}

cmd_build_cli() {
  echo "» building cli → $BINARY_DIR/$CLI_BINARY"
  go build -o "$BINARY_DIR/$CLI_BINARY" ./cli/cmd/bf
  ln -sf "$CLI_BINARY" "$BINARY_DIR/bifrost"
}

cmd_docker() {
  echo "» docker build"
  docker build -t bifrost:latest .
}

cmd_clean() {
  echo "» cleaning $BINARY_DIR/"
  rm -rf "$BINARY_DIR/"
}

cmd_list() {
  echo "Available modules:"
  for mod in "${MODULES[@]}"; do
    echo "  $mod"
  done
}

# ── Dispatch ─────────────────────────────────────────────────────────────────

if [[ $# -eq 0 ]]; then
  usage 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
  test)          cmd_test "$@" ;;
  lint)          cmd_lint "$@" ;;
  vet)           cmd_vet "$@" ;;
  tidy)          cmd_tidy "$@" ;;
  build)         cmd_build ;;
  build-server)  cmd_build_server ;;
  build-cli)     cmd_build_cli ;;
  docker)        cmd_docker ;;
  clean)         cmd_clean ;;
  list)          cmd_list ;;
  help|--help|-h) usage 0 ;;
  *)
    echo "error: unknown command '$COMMAND'" >&2
    usage 1
    ;;
esac
