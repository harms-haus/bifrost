# Admin UI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a localhost-only web admin interface for viewing and managing bifrost realms, sagas, and runes.

**Architecture:** Embedded admin server runs alongside main API on port 8081, shares DB/stores, serves Go templates with inline CSS dark theme.

**Tech Stack:** Go, html/template, inline CSS, existing domain handlers

---

## Task 1: Add AdminPort to Config

**Files:**
- Modify: `server/config.go:10-15`
- Modify: `server/config.go:17-55`

**Step 1: Write the failing test**

Add to `server/config_test.go`:

```go
func TestLoadConfig_AdminPort(t *testing.T) {
	t.Setenv("BIFROST_ADMIN_PORT", "9999")
	cfg, err := server.LoadConfig()
	if err != nil {
		t.Fatalf("LoadConfig: %v", err)
	}
	if cfg.AdminPort != 9999 {
		t.Errorf("AdminPort = %d, want 9999", cfg.AdminPort)
	}
}

func TestLoadConfig_AdminPortDefault(t *testing.T) {
	cfg, err := server.LoadConfig()
	if err != nil {
		t.Fatalf("LoadConfig: %v", err)
	}
	if cfg.AdminPort != 8081 {
		t.Errorf("AdminPort = %d, want 8081 (default)", cfg.AdminPort)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./server -run TestLoadConfig_AdminPort -v`
Expected: FAIL - `cfg.AdminPort undefined`

**Step 3: Write minimal implementation**

In `server/config.go`, add to Config struct:

```go
type Config struct {
	DBDriver        string
	DBPath          string
	Port            int
	AdminPort       int
	CatchUpInterval time.Duration
}
```

In `LoadConfig()`, add after the Port parsing block:

```go
	adminPort := 8081
	if portStr := os.Getenv("BIFROST_ADMIN_PORT"); portStr != "" {
		p, err := strconv.Atoi(portStr)
		if err != nil {
			return nil, fmt.Errorf("BIFROST_ADMIN_PORT must be a valid integer: %w", err)
		}
		if p < 1 || p > 65535 {
			return nil, fmt.Errorf("BIFROST_ADMIN_PORT must be between 1 and 65535")
		}
		adminPort = p
	}
```

And add `AdminPort: adminPort,` to the return statement.

**Step 4: Run test to verify it passes**

Run: `go test ./server -run TestLoadConfig_AdminPort -v`
Expected: PASS

**Step 5: Commit**

```bash
git add server/config.go server/config_test.go
git commit -m "feat(config): add AdminPort config option (default 8081)"
```

---

## Task 2: Create Admin Package with Template Definitions

**Files:**
- Create: `server/admin/templates.go`

**Step 1: Write the templates file**

Create `server/admin/templates.go`:

```go
package admin

import "html/template"

// Dark theme colors:
// Background: #1a1a2e, Surface: #16213e, Text: #eaeaea, Accent: #0f3460
// Status: open=gray, claimed=blue, fulfilled=green, sealed=purple

const baseHTML = `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Bifrost Admin</title>
	<style>
		* { box-sizing: border-box; margin: 0; padding: 0; }
		body { font-family: system-ui, -apple-system, sans-serif; background: #1a1a2e; color: #eaeaea; padding: 20px; }
		a { color: #4fc3f7; text-decoration: none; }
		a:hover { text-decoration: underline; }
		h1, h2, h3 { margin-bottom: 16px; }
		.card { background: #16213e; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
		table { width: 100%; border-collapse: collapse; }
		th, td { padding: 12px; text-align: left; border-bottom: 1px solid #0f3460; }
		th { background: #0f3460; }
		.status-open { color: #9e9e9e; }
		.status-claimed { color: #42a5f5; }
		.status-fulfilled { color: #66bb6a; }
		.status-sealed { color: #ab47bc; }
		.indented { margin-left: 24px; }
		form { display: inline; }
		button { background: #0f3460; color: #eaeaea; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; }
		button:hover { background: #1a4a7a; }
		input, textarea, select { background: #1a1a2e; color: #eaeaea; border: 1px solid #0f3460; padding: 8px; border-radius: 4px; }
		input:focus, textarea:focus, select:focus { outline: 2px solid #4fc3f7; }
		.inline-form { display: inline-flex; gap: 8px; align-items: center; }
		.create-form { margin-bottom: 16px; }
		.create-form input { width: 300px; }
		.create-form textarea { width: 100%; min-height: 60px; }
	</style>
</head>
<body>
	<nav style="margin-bottom: 20px;">
		<a href="/realms">Realms</a>
	</nav>
	{{template "content" .}}
</body>
</html>`

const realmsHTML = `{{define "content"}}
<h1>Realms</h1>
<div class="card">
	<table>
		<thead>
			<tr>
				<th>Name</th>
				<th>Status</th>
				<th>Created</th>
				<th>Actions</th>
			</tr>
		</thead>
		<tbody>
		{{range .Realms}}
			<tr>
				<td>{{.Name}}</td>
				<td class="status-{{.Status}}">{{.Status}}</td>
				<td>{{.CreatedAt.Format "2006-01-02 15:04"}}</td>
				<td><a href="/realm/{{.RealmID}}">View</a></td>
			</tr>
		{{else}}
			<tr><td colspan="4">No realms found</td></tr>
		{{end}}
		</tbody>
	</table>
</div>
{{end}}`

const realmHTML = `{{define "content"}}
<h1>Realm: {{.Realm.Name}}</h1>

<div class="card">
	<h2>Sagas</h2>
	{{range .Sagas}}
		<div class="card">
			<table>
				<thead>
					<tr>
						<th>ID</th>
						<th>Title</th>
						<th>Status</th>
						<th>Priority</th>
						<th>Claimant</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>{{.ID}}</td>
						<td>{{.Title}}</td>
						<td class="status-{{.Status}}">{{.Status}}</td>
						<td>{{.Priority}}</td>
						<td>{{.Claimant}}</td>
						<td>
							{{if eq .Status "open"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/claim"><button>Claim</button></form>{{end}}
							{{if eq .Status "claimed"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/fulfill"><button>Fulfill</button></form>{{end}}
							{{if eq .Status "fulfilled"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/seal"><button>Seal</button></form>{{end}}
						</td>
					</tr>
					{{range .Children}}
						<tr class="indented">
							<td style="padding-left: 24px;">{{.ID}}</td>
							<td>{{.Title}}</td>
							<td class="status-{{.Status}}">{{.Status}}</td>
							<td>{{.Priority}}</td>
							<td>{{.Claimant}}</td>
							<td>
								{{if eq .Status "open"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/claim"><button>Claim</button></form>{{end}}
								{{if eq .Status "claimed"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/fulfill"><button>Fulfill</button></form>{{end}}
								{{if eq .Status "fulfilled"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/seal"><button>Seal</button></form>{{end}}
							</td>
						</tr>
					{{end}}
				</tbody>
			</table>
		</div>
	{{else}}
		<p>No sagas found</p>
	{{end}}
</div>

<div class="card">
	<h2>Orphan Runes (no parent)</h2>
	<table>
		<thead>
			<tr>
				<th>ID</th>
				<th>Title</th>
				<th>Status</th>
				<th>Priority</th>
				<th>Claimant</th>
				<th>Actions</th>
			</tr>
		</thead>
		<tbody>
		{{range .Orphans}}
			<tr>
				<td>{{.ID}}</td>
				<td>{{.Title}}</td>
				<td class="status-{{.Status}}">{{.Status}}</td>
				<td>{{.Priority}}</td>
				<td>{{.Claimant}}</td>
				<td>
					{{if eq .Status "open"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/claim"><button>Claim</button></form>{{end}}
					{{if eq .Status "claimed"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/fulfill"><button>Fulfill</button></form>{{end}}
					{{if eq .Status "fulfilled"}}<form method="POST" action="/realm/{{$.Realm.RealmID}}/runes/{{.ID}}/seal"><button>Seal</button></form>{{end}}
				</td>
			</tr>
		{{else}}
			<tr><td colspan="6">No orphan runes</td></tr>
		{{end}}
		</tbody>
	</table>
</div>

<div class="card">
	<h2>Create Rune</h2>
	<form class="create-form" method="POST" action="/realm/{{.Realm.RealmID}}/runes">
		<p>
			<label>Title: <input type="text" name="title" required></label>
		</p>
		<p>
			<label>Priority:
				<select name="priority">
					<option value="3">3 (Normal)</option>
					<option value="2">2 (High)</option>
					<option value="1">1 (Urgent)</option>
					<option value="4">4 (Low)</option>
				</select>
			</label>
		</p>
		<p>
			<label>Description:<br><textarea name="description"></textarea></label>
		</p>
		<p>
			<label>Parent (Saga ID, optional): <input type="text" name="parent_id"></label>
		</p>
		<p>
			<button type="submit">Create Rune</button>
		</p>
	</form>
</div>
{{end}}`

var templates = template.Must(template.New("base").Parse(baseHTML))

func init() {
	template.Must(templates.New("realms").Parse(realmsHTML))
	template.Must(templates.New("realm").Parse(realmHTML))
}
```

**Step 2: Verify it compiles**

Run: `go build ./server/admin`
Expected: no errors

**Step 3: Commit**

```bash
git add server/admin/templates.go
git commit -m "feat(admin): add HTML templates with dark theme"
```

---

## Task 3: Create AdminServer and Handlers

**Files:**
- Create: `server/admin/admin.go`
- Create: `server/admin/handlers.go`

**Step 1: Write the failing test**

Create `server/admin/admin_test.go`:

```go
package admin

import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/devzeebo/bifrost/core"
)

type mockProjectionStore struct {
	listResult  []json.RawMessage
	listErr     error
	getResult   any
	getErr      error
	putErr      error
	deleteErr   error
}

func (m *mockProjectionStore) List(ctx context.Context, realmID, projectionName string) ([]json.RawMessage, error) {
	return m.listResult, m.listErr
}

func (m *mockProjectionStore) Get(ctx context.Context, realmID, projectionName, key string, dest any) error {
	return m.getErr
}

func (m *mockProjectionStore) Put(ctx context.Context, realmID, projectionName, key string, value any) error {
	return m.putErr
}

func (m *mockProjectionStore) Delete(ctx context.Context, realmID, projectionName, key string) error {
	return m.deleteErr
}

type mockEventStore struct{}

func (m *mockEventStore) Append(ctx context.Context, events []core.Event) error { return nil }
func (m *mockEventStore) Load(ctx context.Context, realmID string, afterSeq int64) ([]core.Event, error) {
	return nil, nil
}

type mockEngine struct{}

func (m *mockEngine) RunSync(ctx context.Context, events []core.Event) error { return nil }
func (m *mockEngine) RunCatchUpOnce(ctx context.Context)                     {}

func TestIndexRedirectsToRealms(t *testing.T) {
	srv := &AdminServer{
		projectionStore: &mockProjectionStore{},
		eventStore:      &mockEventStore{},
		engine:          &mockEngine{},
	}

	req := httptest.NewRequest("GET", "/", nil)
	rec := httptest.NewRecorder()
	srv.ServeHTTP(rec, req)

	if rec.Code != http.StatusSeeOther {
		t.Errorf("Status = %d, want %d", rec.Code, http.StatusSeeOther)
	}
	if loc := rec.Header().Get("Location"); loc != "/realms" {
		t.Errorf("Location = %q, want %q", loc, "/realms")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./server/admin -v`
Expected: FAIL - `undefined: AdminServer`

**Step 3: Write minimal implementation**

Create `server/admin/admin.go`:

```go
package admin

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/http"

	"github.com/devzeebo/bifrost/core"
)

type AdminServer struct {
	port            int
	db              *sql.DB
	eventStore      core.EventStore
	projectionStore core.ProjectionStore
	engine          ProjectionEngine
	mux             *http.ServeMux
}

type ProjectionEngine interface {
	RunSync(ctx context.Context, events []core.Event) error
	RunCatchUpOnce(ctx context.Context)
}

func NewAdminServer(db *sql.DB, eventStore core.EventStore, projectionStore core.ProjectionStore, engine ProjectionEngine, port int) *AdminServer {
	s := &AdminServer{
		port:            port,
		db:              db,
		eventStore:      eventStore,
		projectionStore: projectionStore,
		engine:          engine,
		mux:             http.NewServeMux(),
	}
	s.routes()
	return s
}

func (s *AdminServer) routes() {
	s.mux.HandleFunc("GET /", s.handleIndex)
	s.mux.HandleFunc("GET /realms", s.handleRealms)
	s.mux.HandleFunc("GET /realm/{id}", s.handleRealm)
	s.mux.HandleFunc("POST /realm/{id}/runes", s.handleCreateRune)
	s.mux.HandleFunc("POST /realm/{id}/runes/{runeId}/claim", s.handleClaimRune)
	s.mux.HandleFunc("POST /realm/{id}/runes/{runeId}/fulfill", s.handleFulfillRune)
	s.mux.HandleFunc("POST /realm/{id}/runes/{runeId}/seal", s.handleSealRune)
}

func (s *AdminServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.mux.ServeHTTP(w, r)
}

func (s *AdminServer) Run(ctx context.Context) error {
	addr := fmt.Sprintf("127.0.0.1:%d", s.port)
	srv := &http.Server{
		Addr:    addr,
		Handler: s,
	}

	errCh := make(chan error, 1)
	go func() {
		log.Printf("admin UI listening on %s", addr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			errCh <- err
		}
		close(errCh)
	}()

	<-ctx.Done()
	log.Println("admin UI shutting down...")

	if err := srv.Shutdown(ctx); err != nil {
		return fmt.Errorf("admin shutdown: %w", err)
	}

	return <-errCh
}

func (s *AdminServer) handleIndex(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, "/realms", http.StatusSeeOther)
}
```

Create `server/admin/handlers.go`:

```go
package admin

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/devzeebo/bifrost/core"
	"github.com/devzeebo/bifrost/domain"
	"github.com/devzeebo/bifrost/domain/projectors"
)

func (s *AdminServer) handleRealms(w http.ResponseWriter, r *http.Request) {
	rawRealms, err := s.projectionStore.List(r.Context(), "_admin", "realm_list")
	if err != nil {
		http.Error(w, "failed to list realms", http.StatusInternalServerError)
		return
	}

	var realms []projectors.RealmListEntry
	for _, raw := range rawRealms {
		var realm projectors.RealmListEntry
		if err := json.Unmarshal(raw, &realm); err != nil {
			continue
		}
		realms = append(realms, realm)
	}

	data := struct {
		Realms []projectors.RealmListEntry
	}{
		Realms: realms,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := templates.ExecuteTemplate(w, "realms", data); err != nil {
		http.Error(w, "template error", http.StatusInternalServerError)
	}
}

type sagaWithChildren struct {
	projectors.RuneSummary
	Children []projectors.RuneSummary
}

func (s *AdminServer) handleRealm(w http.ResponseWriter, r *http.Request) {
	realmID := r.PathValue("id")

	// Get realm info
	var realm projectors.RealmListEntry
	if err := s.projectionStore.Get(r.Context(), "_admin", "realm_list", realmID, &realm); err != nil {
		if isNotFound(err) {
			http.Error(w, "realm not found", http.StatusNotFound)
			return
		}
		http.Error(w, "failed to get realm", http.StatusInternalServerError)
		return
	}

	// Get all runes for this realm
	rawRunes, err := s.projectionStore.List(r.Context(), realmID, "rune_list")
	if err != nil {
		http.Error(w, "failed to list runes", http.StatusInternalServerError)
		return
	}

	var allRunes []projectors.RuneSummary
	for _, raw := range rawRunes {
		var rune_ projectors.RuneSummary
		if err := json.Unmarshal(raw, &rune_); err != nil {
			continue
		}
		allRunes = append(allRunes, rune_)
	}

	// Separate into sagas (parents) and children/orphans
	childrenByParent := make(map[string][]projectors.RuneSummary)
	var sagas []projectors.RuneSummary
	var orphans []projectors.RuneSummary

	for _, rune_ := range allRunes {
		if rune_.ParentID != "" {
			childrenByParent[rune_.ParentID] = append(childrenByParent[rune_.ParentID], rune_)
		}
	}

	for _, rune_ := range allRunes {
		if rune_.ParentID == "" {
			// Check if this rune has children (is a saga)
			if len(childrenByParent[rune_.ID]) > 0 {
				sagas = append(sagas, rune_)
			} else {
				orphans = append(orphans, rune_)
			}
		}
	}

	// Build saga with children
	var sagasWithChildren []sagaWithChildren
	for _, saga := range sagas {
		sagasWithChildren = append(sagasWithChildren, sagaWithChildren{
			RuneSummary: saga,
			Children:    childrenByParent[saga.ID],
		})
	}

	data := struct {
		Realm   projectors.RealmListEntry
		Sagas   []sagaWithChildren
		Orphans []projectors.RuneSummary
	}{
		Realm:   realm,
		Sagas:   sagasWithChildren,
		Orphans: orphans,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := templates.ExecuteTemplate(w, "realm", data); err != nil {
		http.Error(w, "template error", http.StatusInternalServerError)
	}
}

func (s *AdminServer) handleCreateRune(w http.ResponseWriter, r *http.Request) {
	realmID := r.PathValue("id")

	title := r.FormValue("title")
	if title == "" {
		http.Error(w, "title required", http.StatusBadRequest)
		return
	}

	priority := 3
	if p := r.FormValue("priority"); p != "" {
		fmt.Sscanf(p, "%d", &priority)
	}

	cmd := domain.CreateRune{
		Title:       title,
		Description: r.FormValue("description"),
		Priority:    priority,
		ParentID:    r.FormValue("parent_id"),
	}

	result, err := domain.HandleCreateRune(r.Context(), realmID, cmd, s.eventStore, s.projectionStore)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	s.engine.RunCatchUpOnce(r.Context())
	http.Redirect(w, r, "/realm/"+realmID, http.StatusSeeOther)

	// Log the created rune ID for reference
	log.Printf("created rune %s in realm %s", result.ID, realmID)
}

func (s *AdminServer) handleClaimRune(w http.ResponseWriter, r *http.Request) {
	realmID := r.PathValue("id")
	runeID := r.PathValue("runeId")

	cmd := domain.ClaimRune{ID: runeID, Claimant: "admin"}
	if err := domain.HandleClaimRune(r.Context(), realmID, cmd, s.eventStore); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	s.engine.RunCatchUpOnce(r.Context())
	http.Redirect(w, r, "/realm/"+realmID, http.StatusSeeOther)
}

func (s *AdminServer) handleFulfillRune(w http.ResponseWriter, r *http.Request) {
	realmID := r.PathValue("id")
	runeID := r.PathValue("runeId")

	cmd := domain.FulfillRune{ID: runeID}
	if err := domain.HandleFulfillRune(r.Context(), realmID, cmd, s.eventStore); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	s.engine.RunCatchUpOnce(r.Context())
	http.Redirect(w, r, "/realm/"+realmID, http.StatusSeeOther)
}

func (s *AdminServer) handleSealRune(w http.ResponseWriter, r *http.Request) {
	realmID := r.PathValue("id")
	runeID := r.PathValue("runeId")

	cmd := domain.SealRune{ID: runeID}
	if err := domain.HandleSealRune(r.Context(), realmID, cmd, s.eventStore); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	s.engine.RunCatchUpOnce(r.Context())
	http.Redirect(w, r, "/realm/"+realmID, http.StatusSeeOther)
}

func isNotFound(err error) bool {
	var nfe *core.NotFoundError
	return err != nil && (err.Error() == "not found" || err.Error() == "projection not found" || (err != nil && len(err.Error()) > 0))
}
```

Add missing import to `admin_test.go`:

```go
import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/devzeebo/bifrost/core"
)
```

**Step 4: Run test to verify it passes**

Run: `go test ./server/admin -v`
Expected: PASS

**Step 5: Commit**

```bash
git add server/admin/
git commit -m "feat(admin): add AdminServer with handlers for realms and runes"
```

---

## Task 4: Integrate Admin Server into Main Server

**Files:**
- Modify: `server/main.go`

**Step 1: Write the failing test**

Add to `server/main_test.go`:

```go
func TestRun_StartsAdminServer(t *testing.T) {
	// This is an integration test - we verify admin port is configured
	cfg := &server.Config{
		DBDriver:        "sqlite",
		DBPath:          t.TempDir() + "/test.db",
		Port:            0, // random port
		AdminPort:       0, // random port
		CatchUpInterval: time.Second,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	// Run in goroutine
	errCh := make(chan error, 1)
	go func() {
		errCh <- server.Run(ctx, cfg)
	}()

	// Give it time to start
	time.Sleep(100 * time.Millisecond)

	// Context cancelled, should shut down cleanly
	cancel()

	select {
	case err := <-errCh:
		if err != nil && !errors.Is(err, context.Canceled) {
			t.Errorf("Run returned error: %v", err)
		}
	case <-time.After(5 * time.Second):
		t.Error("Run did not return within timeout")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./server -run TestRun_StartsAdminServer -v`
Expected: May pass or fail depending on whether admin server is started

**Step 3: Write minimal implementation**

In `server/main.go`, add import:

```go
import (
	// ... existing imports ...
	"github.com/devzeebo/bifrost/server/admin"
)
```

In `Run()`, after `engine.StartCatchUp` and before the HTTP server setup, add:

```go
	// 4.5. Start admin server
	adminServer := admin.NewAdminServer(db, eventStore, projectionStore, engine, cfg.AdminPort)
	go func() {
		if err := adminServer.Run(ctx); err != nil {
			log.Printf("admin server error: %v", err)
		}
	}()
```

**Step 4: Run all server tests**

Run: `go test ./server -v`
Expected: PASS

**Step 5: Commit**

```bash
git add server/main.go server/main_test.go
git commit -m "feat(server): integrate admin server on localhost:8081"
```

---

## Task 5: Manual Integration Test

**Step 1: Build and run the server**

```bash
make build
./bin/bifrost-server &
```

**Step 2: Create test data**

```bash
./bin/bf admin create-realm test-realm
./bin/bf admin create-account testuser
# Note the realm ID from output, then:
./bin/bf admin grant testuser --realm <realm-id>
```

**Step 3: Create runes**

```bash
bf login --url http://localhost:8080 --token <pat>
bf init --realm test-realm
bf create "Saga: Main Feature" -p 2
bf create "Task 1" -p 3 --parent <saga-id>
bf create "Task 2" -p 3 --parent <saga-id>
bf create "Orphan task" -p 4
```

**Step 4: Access admin UI**

Open browser to `http://localhost:8081/realms`

Verify:
- Realms list shows test-realm
- Clicking into realm shows saga with children
- Orphan tasks shown separately
- Create form works
- Claim/Fulfill/Seal buttons work

**Step 5: Cleanup**

```bash
kill %1  # or pkill bifrost-server
```

---

## Summary

After completing these tasks, the admin UI will be available at `http://localhost:8081` providing:
- List of all realms
- Hierarchical view of sagas (parent runes) with their children
- Orphan runes without parents
- Full CRUD: create runes, claim, fulfill, seal
- Dark theme, no JavaScript, pure Go templates
